'use strict';

let fascis = {
  preComutClosure: (closureForFn) => closureForFn,
  comutClosure: (closureForFn) => closureForFn,
  closureToMoresFn: (bfn, closureForFn) => (closureForFn, bfn),
  returnBfn: (bfn, closureForFn) => (closureForFn, bfn),
};

const operati = {
  closureForFn: {
    context: {
      max: 0,
      counter: 0,
    },
    time: { msec: 0, },
    timer: {
      timeout: null,
      interval: null,
    },
    flags: {
      kill: false,
    }
  },
  thisForFn: {},
};



const artus = (fn) => {

  const methods = {
    printFn() {
      console.log(operati.closureForFn.bfn);
      return this;
    },
    limit(max){
      operati.closureForFn.context.max = max;
      return this;
    },
    timer(msec) {
      const ms = operati.closureForFn.time.msec = msec;
      const timer_ = setTimeout(() => {
        operati.closureForFn.flags.kill = true;
        timer_.close();
      }, ms);
      return this;
    }
  };

  operati.closureForFn = fascis.preComutClosure(operati.closureForFn);

  const exitus = function(...args) {

    const bfn = fn.bind(operati.thisForFn);

    const properties = {
      bfn: bfn,
      args: args,
      closureForFn: operati.closureForFn,
      thisForFn: operati.thisForFn,
    };
    exitus.getOperati = () => properties;
    const moresFn = fascis.closureToMoresFn(bfn, operati.closureForFn);
    // comutatus closure
    operati.closureForFn = fascis.comutClosure(operati.closureForFn);
    // reditum moresFn
    const metus = fascis.returnBfn(moresFn, operati.closureForFn);

    if (metus) metus(...args);

  };

  Object.assign(exitus, methods);

  return exitus;
};

artus.fascis = fascis;


module.exports = { artus };
