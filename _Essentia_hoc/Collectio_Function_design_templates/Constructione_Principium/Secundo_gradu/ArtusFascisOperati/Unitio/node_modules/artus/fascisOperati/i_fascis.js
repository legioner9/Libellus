'use strict';

const { artus } = require('artus');

const closureForFn = {
  cache: new Map(),
  lengthCache: 1,
  timeout: 0,
  limit: 0,
  size: 0,
  maxSize: 0,
  maxCount: 0,
  events: {
    timeout: null,
    memoize: null,
    overflow: null,
    add: null,
    del: null,
    clear: null,
  },
};

const objProto = {
  clearCache() {
    communis.closureForFn.cache.clear();
    return this;
  },
  addCache(key, err, data) {
    this.emitEventCache('add', err, data);
    communis.closureForFn.cache.set(key, { err, data });
    return this;
  },
  delCache(key) {
    this.emitEventCache('del', key);
    communis.closureForFn.cache.delete(key);
    return this;
  },
  getCache(key, callback) {
    const record = communis.closureForFn.cache.get(key);
    callback(record.err, record.data);
    return this;
  },
  onEventCache(eventName, listener) {
    debugger
    if (eventName in communis.closureForFn.events) {
      communis.closureForFn.events[eventName] = listener;
    }
    return this;
  },
  emitEventCache(eventName, ...args) {
    const event = communis.closureForFn.events[eventName];
    if (event) event(...args);
  }
};

const internus = function(memoized, communis, fn, ...args) {
  const callback = args.pop();

  const key = communis.alius.generateKey(args);
  const value = communis.closureForFn.cache.get(key);

  if (communis.closureForFn.cache.has(key)) {
    console.log(`from cache key: ${key}`);
    callback(value.err, value.data);
    return;
  }
  fn(...args, (err, data) => {
    // cache.set(key, { err, data });
    memoized.addCache(key, err, data);
    memoized.emitEventCache('memoize', key, err, data);
    if (communis.closureForFn.cache.size > communis.closureForFn.lengthCache) {
      const firstKey = communis.closureForFn.cache.keys().next().value;
      console.log(`cache deleted key: ${firstKey}`);
      communis.closureForFn.cache.delete(firstKey);
    }
    console.log(`callback called with args: ${err},${data}`);
    callback(err, data);
  });
};

const communis = {
  alius: {
    getKey(x) {
      return x.toString() + ':' + typeof x;
    },
    generateKey(arr) {
      const crypto = require('crypto');
      const key = arr.map(this.getKey).join('|');
      return crypto.createHash('sha256').update(key).digest('hex');
    },
  },
  internus,
  anteExitus: (closureForFn) => closureForFn,
  comutClosure: (closureForFn) => closureForFn,
  closureToMoresFn: (bfn, closureForFn) => (closureForFn, bfn),
  returnBfn: (bfn, closureForFn) => () => {
  },
  os: function() {
  },
  closureForFn,
  objProto,
  thisForFn: {},
};

objProto.setLengthCache = function(length) {
  communis.closureForFn.lengthCache = length;
  return this;
};

const memoizeAsync = artus.bind(null, communis);


module.exports = { memoizeAsync };
