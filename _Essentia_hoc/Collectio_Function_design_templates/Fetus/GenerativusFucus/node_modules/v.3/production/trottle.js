 'use strict';

const { propObj, generativusFucus } = require('v.3');

process.start = Date.now();

const nd = (str) => {
  console.log(str, Date.now() - process.start);
};

propObj.returnBfn = (bfn, closureForFn) => {
  nd(`kill ${closureForFn.flags.kill}`);
  if (!closureForFn.flags.kill) {
    return bfn;
  } else return () => undefined;
};

propObj.comutClosure = (closureForFn) => {
  if (closureForFn.context.counter >= closureForFn.context.max) {
    closureForFn.flags.kill = true;
  } else closureForFn.context.counter++;
  return closureForFn;
};

propObj.methods = {
  printFn() {
    console.log(propObj.closureForFn.bfn);
    return this;
  },
  limit(max = 0) {
    propObj.closureForFn.context.max = max;
    return this;
  },
  timer(msec = 0) {
    const timer_ = setTimeout(() => {
      propObj.closureForFn.flags.kill = true;
      timer_.close();
    }, msec);
    return this;
  },
  cancel() {
    propObj.closureForFn.flags.kill = true;
  },
  resume() {
    propObj.closureForFn.flags.kill = false;
  },
  throttle(msec) {
    propObj.closureForFn.timer.interval = setInterval(() => {
      propObj.closureForFn.context.counter = 0;
      propObj.closureForFn.flags.kill = false;
      nd(`trot ${propObj.closureForFn.context.counter}`);
    }, msec);
    return this;
  }
};

const fn = function(...args) {
  console.dir({ args, this: this });
};

// Use

const fucus = generativusFucus(propObj, fn).limit(3);
fucus.throttle(500);

let count = 0;
const interval1 = setInterval(() => {
  nd(`call ${count}`);
  fucus(count++);
}, 100);

const timer1 = setTimeout(() => {
  timer1.close();
  interval1.close();
  propObj.closureForFn.timer.interval.close();
}, 1000);

