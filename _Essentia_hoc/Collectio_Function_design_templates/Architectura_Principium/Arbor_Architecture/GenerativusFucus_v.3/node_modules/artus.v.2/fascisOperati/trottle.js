 'use strict';

const { generativusFucus } = require('artus');

 const propObj = {
   preComutClosure: (closureForFn) => closureForFn,
   comutClosure: (closureForFn) => closureForFn,
   closureToMoresFn: (bfn, closureForFn) => (closureForFn, bfn),
   returnBfn: (bfn, closureForFn) => (closureForFn, bfn),
   methods: {},
   closureForFn: {
     context: {
       max: 0,
       counter: 0,
     },
     time: { msec: 0, },
     timer: {
       timeout: null,
       interval: null,
     },
     flags: {
       kill: false,
     }
   },
   thisForFn: {},
 };

process.start = Date.now();

const nd = (str) => {
  console.log(str, Date.now() - process.start);
};

 propObj.returnBfn = (bfn, closureForFn) => {
  nd(`kill ${closureForFn.flags.kill}`);
  if (!closureForFn.flags.kill) {
    return bfn;
  } else return () => undefined;
};

 propObj.comutClosure = (closureForFn) => {
  if (closureForFn.context.counter >= closureForFn.context.max) {
    closureForFn.flags.kill = true;
  } else closureForFn.context.counter++;
  return closureForFn;
};

 propObj.methods = {
  printFn() {
    console.log(propObj.closureForFn.bfn);
    return this;
  },
  limit(max = 0) {
    propObj.closureForFn.context.max = max;
    return this;
  },
  timer(msec = 0) {
    const timer_ = setTimeout(() => {
      propObj.closureForFn.flags.kill = true;
      timer_.close();
    }, msec);
    return this;
  },
  cancel() {
    propObj.closureForFn.flags.kill = true;
  },
  resume() {
    propObj.closureForFn.flags.kill = false;
  },
  throttle(msec) {
    propObj.closureForFn.timer.interval = setInterval(() => {
      propObj.closureForFn.context.counter = 0;
      propObj.closureForFn.flags.kill = false;
      nd(`trot ${propObj.closureForFn.context.counter}`);
    }, msec);
    return this;
  }
};

const fn = function(...args) {
  console.dir({ args, this: this });
};

// Use

const fucus = generativusFucus(propObj, fn).limit(3);
fucus.throttle(500);

let count = 1;
const interval1 = setInterval(() => {
  nd(`call ${count}`);
  fucus(count++);
}, 100);

const timer1 = setTimeout(() => {
  timer1.close();
  interval1.close();
  propObj.closureForFn.timer.interval.close();
}, 1000);

