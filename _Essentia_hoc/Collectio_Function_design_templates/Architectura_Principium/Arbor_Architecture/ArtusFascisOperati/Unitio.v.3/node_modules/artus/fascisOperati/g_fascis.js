'use strict';

const { artus } = require('artus');

const objProto = {
  printBFn() {
    console.log(this.getOstium().bfn);
    return this;
  },
  setLimit(max) {
    communis.closure.context.max = max;
    return this;
  },
  setTimer(msec) {
    const ms = communis.closure.time.msec = msec;
    const timer_ = setTimeout(() => {
      communis.closure.flags.kill = true;
      timer_.close();
    }, ms);
    return this;
  }
};

const internus = (exitus, communis, fn, ...args) => {

  if (communis.closure.context.counter === communis.closure.context.max) communis.closure.flags.kill = true;
  else communis.closure.context.counter++;

  if (!communis.closure.flags.kill) {
    return fn(...args);
  } else return () => undefined;

};

const communis = {
  alius: {
    method() {
    },
  },
  internus,
  anteExitus: (closureForFn) => closureForFn,
  // comutClosure: (closureForFn) => closureForFn,
  // closureToMoresFn: (bfn, closureForFn) => (closureForFn, bfn),
  // returnBfn: (bfn, closureForFn) => () => {
  // },
  os: function() {
  },
  objProto,
  closure: {
    context: {
      max: 0,
      counter: 0,
    },
    time: { msec: 0, },
    timer: {
      timeout: null,
      interval: null,
    },
    flags: {
      kill: false,
    }
  },
};

communis.returnBfn = (bfn, closureForFn) => {
  if (!closureForFn.flags.kill) {
    return bfn;
  } else return () => undefined;
};

communis.comutClosure = (closureForFn) => {
  if (closureForFn.context.counter === closureForFn.context.max) closureForFn.flags.kill = true;
  else closureForFn.context.counter++;
  return closureForFn;
};


const timer = artus.bind(null, communis);

module.exports = { timer };
