'use strict';

const { memoizeAsync } = require('artus.v.2');

// Usu
const fn = (x, callback) => {
  if (typeof x !== 'number') callback('argument is not a number');
  callback(null, x);
};

const callback = (...args) => args;

const props = {
  cache: new Map(),
  timeout: 0,
  limit: 0,
  size: 0,
  maxSize: 0,
  maxCount: 0,
  events: {
    timeout: null,
    memoize: null,
    overflow: null,
    add: null,
    del: null,
    clear: null,
  },
};

const objProto = {
  clear() {
    this.cache.clear();
  },
  add(key, err, data) {
    this.emit('add', err, data);
    this.cache.set(key, { err, data });
    return this;
  },
  del(key) {
    this.emit('del', key);
    this.cache.delete(key);
    return this;
  },
  get(key, callback) {
    const record = this.cache.get(key);
    callback(record.err, record.data);
    return this;
  },
  on(eventName, listener) {
    if (eventName in this.events) {
      this.events[eventName] = listener;
    }
  },
  emit(eventName, ...args) {
    const event = this.events[eventName];
    if (event) event(...args);
  }
};

const communis = {
  alius: {
    getKey(x) {
      return x.toString() + ':' + typeof x;
    },
    generateKey(arr) {
      const crypto = require('crypto');
      const key = arr.map(this.getKey).join('|');
      return crypto.createHash('sha256').update(key).digest('hex');
    },
  },
  os: function() {
  },
  lengthCache: 1,
  props,
  objProto,
};
const mfn = memoizeAsync(communis, fn);

mfn.on('add', (...data) => {
  console.log('event add called with: ', data);
});
// mfn.addPrototypes(objProto);

mfn(1, callback);
debugger
mfn.clear();
debugger
mfn(1, callback);
mfn(1, callback);
debugger
mfn(2, callback);
debugger
