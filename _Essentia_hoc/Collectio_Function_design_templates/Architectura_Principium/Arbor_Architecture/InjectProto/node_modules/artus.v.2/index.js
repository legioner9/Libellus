'use strict';

// const crypto = require('crypto');
//
// const getKey = (x) => x.toString() + ':' + typeof x;
//
// const generateKey = (arr) => {
//   const key = arr.map(getKey).join('|');
//   return crypto.createHash('sha256').update(key).digest('hex');
// };


const memoizeAsync = (communis, fn) => {
  // const Memoized = function() {
  // };
  // const cache = new Map();
  const memoized = (...args) => {

    const callback = args.pop();
    debugger
    const key = communis.alius.generateKey(args);
    const value = communis.props.cache.get(key);
    debugger
    if (communis.props.cache.has(key)) {
      console.log(`from cache key: ${key}`);
      callback(value.err, value.data);
      return;
    }
    fn(...args, (err, data) => {
      // cache.set(key, { err, data });
      memoized.add(key, err, data);
      memoized.emit('memoize', key, err, data);
      if (communis.props.cache.size > communis.lengthCache) {
        const firstKey = communis.props.cache.keys().next().value;
        console.log(`cache deleted key: ${firstKey}`);
        communis.props.cache.delete(firstKey);
      }
      console.log(`callback called with args: ${err},${data}`);
      callback(err, data);
    });
  };

  // communis.props.cache = cache;

  for (const key in communis.objProto) {
    if (communis.objProto.hasOwnProperty(key)) communis.os.prototype[key] = communis.objProto[key];
  }

  Object.setPrototypeOf(memoized, communis.os.prototype);
  return Object.assign(memoized, communis.props);
};

module.exports = { memoizeAsync };
