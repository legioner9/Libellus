'use strict';

const crypto = require('crypto');

const getKey = (x) => x.toString() + ':' + typeof x;

const generateKey = (arr) => {
  const key = arr.map(getKey).join('|');
  return crypto.createHash('sha256').update(key).digest('hex');
};

const Memoized = function() {
};

const memoizeAsync = (fn, length = 2) => {
  const cache = new Map();
  const memoized = (...args) => {

    const callback = args.pop();
    const key = generateKey(args);
    const value = cache.get(key);
    if (cache.has(key)) {
      console.log(`from cache key: ${key}`);
      callback(value.err, value.data);
      return;
    }
    debugger
    fn(...args, (err, data) => {
      // cache.set(key, { err, data });
      memoized.add(key, err, data);
      memoized.emit('memoize', key, err, data);
      if (cache.size >= length) {
        const firstKey = cache.keys().next().value;
        console.log(`cache deleted key: ${firstKey}`);
        cache.delete(firstKey);
      }
      console.log(`callback called with args: ${err},${data}`);
      callback(err, data);
    });
  };
  const props = {
    cache,
  };

  Object.defineProperties(memoized, {
    'setProperties': {
      value: function(prop) {
        Object.assign(props, prop)
        return this;
      },
    },
    'addEventName': {
      value: function(name = '') {
        props.events[name] = null;
        return this;
      },
    },
    'addPrototypes': {
      value: function(objProto) {
        for (const key in objProto) {
          if (objProto.hasOwnProperty(key)) Memoized.prototype[key] = objProto[key];
        }
        return this;
      },
    },
  });

  Object.setPrototypeOf(memoized, Memoized.prototype);
  return Object.assign(memoized, props);
};

module.exports = { memoizeAsync }
