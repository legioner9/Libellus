'use strict';

const { artus } = require('artus.v.2');

const closureForFn = {
  cache: new Map(),
  lengthCache: 1,
  timeout: 0,
  limit: 0,
  size: 0,
  maxSize: 0,
  maxCount: 0,
  events: {
    timeout: null,
    memoize: null,
    overflow: null,
    add: null,
    del: null,
    clear: null,
  },
};

const objProto = {
  clear() {
    this.getCommunis().closureForFn.cache.clear();
  },
  add(key, err, data) {
    this.emit('add', err, data);
    this.getCommunis().closureForFn.cache.set(key, { err, data });
    return this;
  },
  del(key) {
    this.emit('del', key);
    this.getCommunis().closureForFn.cache.delete(key);
    return this;
  },
  get(key, callback) {
    const record = this.getCommunis().closureForFn.cache.get(key);
    callback(record.err, record.data);
    return this;
  },
  on(eventName, listener) {

    if (eventName in this.getCommunis().closureForFn.events) {
      this.getCommunis().closureForFn.events[eventName] = listener;
    }
  },
  emit(eventName, ...args) {
    const event = this.getCommunis().closureForFn.events[eventName];
    if (event) event(...args);
  }
};

const internus = function(exitus , communis, fn, ...args) {
  const callback = args.pop();

  const key = communis.alius.generateKey(args);
  const value = communis.closureForFn.cache.get(key);

  if (communis.closureForFn.cache.has(key)) {
    console.log(`from cache key: ${key}`);
    callback(value.err, value.data);
    return;
  }
  fn(...args, (err, data) => {
    // cache.set(key, { err, data });
    exitus.add(key, err, data);
    exitus.emit('memoize', key, err, data);
    if (communis.closureForFn.cache.size > communis.closureForFn.lengthCache) {
      const firstKey = communis.closureForFn.cache.keys().next().value;
      console.log(`cache deleted key: ${firstKey}`);
      communis.closureForFn.cache.delete(firstKey);
    }
    console.log(`callback called with args: ${err},${data}`);
    callback(err, data);
  });
};

const communis = {
  alius: {
    getKey(x) {
      return x.toString() + ':' + typeof x;
    },
    generateKey(arr) {
      const crypto = require('crypto');
      const key = arr.map(this.getKey).join('|');
      return crypto.createHash('sha256').update(key).digest('hex');
    },
  },
  internus,
  os: function() {
  },
  // lengthCache: 1,
  closureForFn,
  objProto,
  thisForFn: {},
};

// Usu
// const fn = (x, callback) => {
//   if (typeof x !== 'number') callback('argument is not a number');
//   callback(null, x);
// };
// const callback = (...args) => args;

// const mfn = memoizeAsync(communis, fn);
//
// mfn.on('add', (...data) => {
//   console.log('event add called with: ', data);
// });
// // mfn.addPrototypes(objProto);
//
// mfn(1, callback);
// debugger
// mfn.clear();
// debugger
// mfn(1, callback);
// mfn(1, callback);
// debugger
// mfn(2, callback);
// debugger


objProto.setLengthCache = (length) => {
  debugger
  communis.closureForFn.lengthCache = length;
}

const ret = artus.bind(null, communis);


module.exports = ret;
